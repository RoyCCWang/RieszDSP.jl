var documenterSearchIndex = {"docs":
[{"location":"api/#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"api/#Frontend","page":"Public API","title":"Frontend","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"getdefaultscale","category":"page"},{"location":"api/#RieszDSP.getdefaultscale","page":"Public API","title":"RieszDSP.getdefaultscale","text":"getdefaultscale(sz_y::Tuple)::Int\n\nreturns the default heuristic on choosing a dyadic scale.     round(Int, log2( maximum(sz_y)))\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"rieszwaveletanalysis","category":"page"},{"location":"api/#RieszDSP.rieszwaveletanalysis","page":"Public API","title":"RieszDSP.rieszwaveletanalysis","text":"rieszwaveletanalysis(y::Array{T}, N_scales::Int) where T <: AbstractFloat\n\nReturn types:\n\nVector{Vector{Array{T,D}}}\nArray{T<:AbstractFloat,D}\n\nreturns WRY, residual. WRY[d][s][n], where:\n\nd is dimension index, up to D.\ns is scale index, up to N_scales.\nn is sampling position index, for a D-dim array.\n\nresidual is the portion of y that doesn't under go the transform. Keep this if you want to do synthesis.\n\nExample: forward Riesz transform (rieszwaveletanalysis) and its inverse transform (rieszwaveletsynthesis)\n\nimport RieszDSP as RZ\nusing LinearAlgebra\n\n# generate input data.\nT = Float64\ny = randn(T, 45, 512, 3)\n\n# specification for the number of wavelet subbands.\nN_scales = round(Int, log2( maximum(size(y))))\n\n# forward transform.\nWRY, residual = RZ.rieszwaveletanalysis(y, N_scales)\n# residual is the portion that does not under go the Riesz-wavelet transform.\n\n# inverse transform.\nyr = RZ.rieszwaveletsynthesis(WRY, residual)\n\n# this is a perfect reconstruction (up to numerical precision), if `residual` is kept.\nprintln(\"relative discrepancy between y and yr: \", norm(y-yr)/norm(y) )\nprintln()\n\n\n\n\n\nrieszwaveletanalysis(     y::Array{T,D},     N_scales::Integer,     order::Integer,     ) where {T <: AbstractFloat,D}\n\nreturns WRY, residual, a_array.\n\nWRY[d][s][n], where:\n\nd is dimension index, up to D.\ns is scale index, up to N_scales.\nn is sampling position index, for a D-dim array.\n\nresidual is the portion of y that doesn't under go the transform. Keep this if you want to do synthesis.\n\naarray: a 1-D array of D-tuples. Each tuple sums to order. The d-th entry of the tuple takes on an integer between 0 and order, and reflects the number of times the Riesz transform is applied in the d-th coordinate axis. In other words, `aarrayis the index set for the multi-indices of aD-dimensional order-L` symmetric tensor.\n\nExample: higher-order Riesz-wavelet transform, round-trip.\n\nimport RieszDSP as RZ\nusing LinearAlgebra\n\n# generate input data.\nT = Float64\ny = randn(T, 45, 512, 3)\n\n# specification for the number of wavelet subbands.\nN_scales = round(Int, log2( maximum(size(y))))\n\n\n# Specify the Riesz transform order.\norder = 7\n\nWRY, residual, a_array = RZ.rieszwaveletanalysis(y, N_scales, order)\n\n# each entry in a_array specifies the number of times the Riesz transform is iterated per dimension.\n# Since our in put `y` is a 3-D array, each entry of `a_array` is a 3-tuple that sums to the order we specified.\nprintln(\"The Riesz order states are:\", a_array)\n\nyr, a_array_rec = RZ.rieszwaveletsynthesis(WRY, residual, order)\nprintln(\"relative discrepancy between y and yr: \", norm(y-yr)/norm(y) )\nprintln()\n\n# The returned Riesz order states from the analysis and synthesis directions of the transform should be the same. The following should be zero.\n@show norm(a_array - a_array_rec)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"rieszwaveletsynthesis","category":"page"},{"location":"api/#RieszDSP.rieszwaveletsynthesis","page":"Public API","title":"RieszDSP.rieszwaveletsynthesis","text":"rieszwaveletsynthesis(     WRY::Vector{Vector{Array{T,D}}},     residual::Array{T,D},     )::Array{T,D} where {T <: AbstractFloat, D}\n\nSee rieszwaveletanalysis for a description of the inputs.\n\nreturns the original input, y of type Array{T,D}.\n\nExample: first-order Riesz-wavelet transform, round-trip.\n\nimport RieszDSP as RZ\nusing LinearAlgebra\n\n# generate input data.\nT = Float64\ny = randn(T, 45, 512, 3)\n\n# specification for the number of wavelet subbands.\nN_scales = round(Int, log2( maximum(size(y))))\n\n# forward transform.\nWRY, residual = RZ.rieszwaveletanalysis(y, N_scales)\n# residual is the portion that does not under go the Riesz-wavelet transform.\n\n# inverse transform.\nyr = RZ.rieszwaveletsynthesis(WRY, residual)\n\n# this is a perfect reconstruction (up to numerical precision), if `residual` is kept.\nprintln(\"relative discrepancy between y and yr: \", norm(y-yr)/norm(y) )\nprintln()\n\n\n\n\n\nrieszwaveletsynthesis(     WRY::Vector{Vector{Array{T,D}}},     residual::Array{T,D},     )::Array{T,D} where {T <: AbstractFloat, D}\n\nSee rieszwaveletanalysis for a description of the inputs.\n\nreturns the original input, y of type Array{T,D}.\n\nExample: higher-order Riesz-wavelet transform, round-trip.\n\nimport RieszDSP as RZ\nusing LinearAlgebra\n\n# generate input data.\nT = Float64\ny = randn(T, 45, 512, 3)\n\n# specification for the number of wavelet subbands.\nN_scales = round(Int, log2( maximum(size(y))))\n\n\n# Specify the Riesz transform order.\norder = 7\n\nWRY, residual, a_array = RZ.rieszwaveletanalysis(y, N_scales, order)\n\n# each entry in a_array specifies the number of times the Riesz transform is iterated per dimension.\n# Since our in put `y` is a 3-D array, each entry of `a_array` is a 3-tuple that sums to the order we specified.\nprintln(\"The Riesz order states are:\", a_array)\n\nyr, a_array_rec = RZ.rieszwaveletsynthesis(WRY, residual, order)\nprintln(\"relative discrepancy between y and yr: \", norm(y-yr)/norm(y) )\nprintln()\n\n# The returned Riesz order states from the analysis and synthesis directions of the transform should be the same. The following should be zero.\n@show norm(a_array - a_array_rec)\n\n\n\n\n\n","category":"function"},{"location":"#RieszDSP.jl","page":"Overview","title":"RieszDSP.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"RieszDSP is a Julia implementation of the forward and inverse transform of the higher-order Riesz-wavelet frame from (Unser et. al. 2011). This transform takes a multi-dimensional array as input, constructs a higher-order Riesz transform, followed by a wavelet transform using a isotropic template filter. So far, only the Simoncelli filter from Unser's article is implemented. This is a perfect reconstruction transform, which means the round-trip discrepancy (i.e., difference between the input array and the array from applying the of the Riesz-wavelet transform and then applying the inverse Riesz-wavelet transform) should be zero, up to numerical precision.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A portion of the code here is based on the Generalized Riesz-Wavelet Toolbox for Matlab authored by Nicolas Chenouard, Dimitri Van De Ville and Michael Unser. Their toolbox as well as RieszDSP use a frequency-domain implementation of filtering operations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The implementation in RieszDSP does not use critical sampling, so each transform response is an array of the same size as the input array. The original implementation from the MATLAB toolbox uses critical sampling, so the transform responses are not arrays of the same size as the input array. See Demo: image analysis for an example.","category":"page"},{"location":"#Specification-of-the-higher-order-Riesz-transform","page":"Overview","title":"Specification of the higher-order Riesz transform","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Let the dimension of the input array be D. Given a positive integer L, the L-th order Riesz transform is a collection of iterated Riesz transforms, each of which is specified by a multi-index a in mathbbAleft(DLright). The index set is defined as:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nleft0Lright  =left 01cdotsLright \nleft0Lright^D  =underbraceleft0Lrighttimesleft0Lrighttimescdotstimesleft0Lright_textD times\nmathbbAleft(DLright)  =left ainleft0Lright^Dmidleftaright=Lright subsetleft0Lright^D\nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The size of the index set is ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nleftmathbbAleft(DLright)right  =beginpmatrixL+D-1\nD-1\nendpmatrix\nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"See Unser 2011 for further details. The set mathbbAleft(DLright) is denoted by a_array in our image analysis demo, and is one of the returned variables from rieszwaveletanalysis","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We refer to the multi-index a as the Riesz order state throughout this documentation. The contents of the state a has D elements, each of which is an integer that takes value from 0 to L. These constraints allow us to use the state a to specify how many times the Riesz transform is applied to the input in the first dimension axis, in the second dimension axis, ..., to the D-th dimension axis. An interesting analogy is that if we replace Riesze transform with the partial derivative operator that acts along one of the D coordinate axes, then we can use a to specify a L-th order partial derivative operator. Essentially, the set of states mathbbAleft(DLright) is the index set for a symmetric tensor. The Riesz transform (and the partial derivative operator for an infinitely differentiable function) along an axis is commutative, that is why we end up with a symmetric tensor of iterated Riesz transforms.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In the demo code, you'll see that the Riesz transform is like a smoothed gradient operator. Given a Riesz order state a, you'll see the edges along the axis where the transform was repeated (according to the contents of a) has a higher magnitude.","category":"page"},{"location":"#Specification-of-the-wavelet-analysis/synthesis","page":"Overview","title":"Specification of the wavelet analysis/synthesis","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The nomenclature used in this documentation is wavelet analysis for the decomposition of an input multi-dimensional array to several multi-dimensional arrays, each called a wavelet subband response and corresponds to a different scale.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Given an input y, a heuristic formula for choosing the number of scales of the wavelet analysis (i.e., the number of subband responses we'd get) is:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"beginalign*\nN_textscales=  leftlfloor log_2left(maxleft N_1N_2cdotsN_Dright right)rightrfloor \nendalign*","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where N_d is the size of the grid in the d-th dimension. For example, a 256 by 512 grayscale image has N_1=256, and N_2=512.","category":"page"},{"location":"#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"M. Unser, N. Chenouard, D. Van de Ville, Steerable Pyramids and Tight Wavelet Frames in L2(Rd), IEEE Transactions on Image Processing, 2011. DOI: 10.1109/TIP.2011.2138147.","category":"page"},{"location":"#Acknowledgement","page":"Overview","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"I thank Nicolas Chenouard and Dimitri Van De Ville for answering questions about their toolbox and the Riesz-wavelet transform.","category":"page"},{"location":"demo/#Demo:-image-analysis","page":"Demo: image analysis","title":"Demo: image analysis","text":"","category":"section"},{"location":"demo/#Load-dependencies","page":"Demo: image analysis","title":"Load dependencies","text":"","category":"section"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"import RieszDSP as RZ\nusing LinearAlgebra\n\nimport PythonPlot as PLT # for visualization\nPLT.close(\"all\")\nfig_num = 1;\n\nimport Images # for loading the image.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"We'll use 64-bit floating point numbers. We will get a higher round-trip discrepancy if we use less precision.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"T = Float64;","category":"page"},{"location":"demo/#Load-image,-and-convert-into-a-2-D-array","page":"Demo: image analysis","title":"Load image, and convert into a 2-D array","text":"","category":"section"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"file_path = \"data/kodim23.png\"\nimg = Images.load(file_path)\ngray_img = Images.Gray.(img)\ny = convert(Array{T}, gray_img); # This is the image, stored as a 2-D array.","category":"page"},{"location":"demo/#Set-specifications,-then-apply-higher-order-Riesz-wavelet-transform-on-y","page":"Demo: image analysis","title":"Set specifications, then apply higher-order Riesz-wavelet transform on y","text":"","category":"section"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"#specifications\norder = 2\nN_scales = round(Int, log2( maximum(size(y))))\n\n#forward transform.\nWRY, residual, a_array = RZ.rieszwaveletanalysis(\n    y, N_scales, order,\n)\nprintln(\"contents of a_array:\")\ndisplay(a_array)\nprintln()","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"contents of a_array:\n\n","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"WRY is a nested array that contains the Riesz-wavelet response of y.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"Given a l and j, WRY[l][j] is the response for the l-th Riesz order state, j-th wavelet analysis subband. The set of all Riesz order states is stored in a_array. The residual is the portion of the input that was excluded from the Riesz-wavelet transform. We need this if we want to do perfect reconstruction given the forward transform responses.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"These two should always have the same length, which is the number of different combinations of iteration for Riesz transform for each dimension.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"@assert length(a_array) == length(WRY)","category":"page"},{"location":"demo/#Visualize","page":"Demo: image analysis","title":"Visualize","text":"","category":"section"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"#maximum intensity.\nvmax = maximum(abs.(y))\n\n#original.\nPLT.figure(fig_num)\nfig_num += 1\nPLT.pcolormesh(\n    1:size(y,2),\n    size(y,1):-1:1,\n    y,\n    #cmap = \"bwr\",\n    cmap = \"gray\",\n    shading = \"auto\",\n    vmin = zero(T),\n    vmax = vmax,\n)\nPLT.colorbar()\nPLT.axis(\"scaled\")\nPLT.xlabel(\"x2 axis\")\nPLT.ylabel(\"x1 axis\")\nPLT.title(\"Original input\")\nPLT.gcf()","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"(Image: )","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"We will just plot the 5-th scale of the wavelet subband for this example.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"j = 3;","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"The first Riesz-order state, subband j.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"l = 1\nprintln(\"Riesz order state: \", a_array[l])\n\nrsp = WRY[l][j]\nZ = max(abs(minimum(rsp)), abs(maximum(rsp)))\n\nPLT.figure(fig_num)\nfig_num += 1\nPLT.pcolormesh(\n    1:size(rsp,2),\n    size(rsp,1):-1:1,\n    rsp,\n    cmap = \"bwr\",\n    #cmap = \"gray\",\n    shading = \"auto\",\n    vmin = -Z,\n    vmax = Z,\n)\nPLT.colorbar()\nPLT.axis(\"scaled\")\nPLT.xlabel(\"x2 axis\")\nPLT.ylabel(\"x1 axis\")\nPLT.title(\"$j-th scale, order-$(a_array[l]) response\")\nPLT.gcf()","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"(Image: )","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"The second Riesz-order state, subband j.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"l = 2\nprintln(\"Riesz order state: \", a_array[l])\n\nrsp = WRY[l][j]\nZ = max(abs(minimum(rsp)), abs(maximum(rsp)))\n\nPLT.figure(fig_num)\nfig_num += 1\nPLT.pcolormesh(\n    1:size(rsp,2),\n    size(rsp,1):-1:1,\n    rsp,\n    cmap = \"bwr\",\n    #cmap = \"gray\",\n    shading = \"auto\",\n    vmin = -Z,\n    vmax = Z,\n)\nPLT.colorbar()\nPLT.axis(\"scaled\")\nPLT.xlabel(\"x2 axis\")\nPLT.ylabel(\"x1 axis\")\nPLT.title(\"$j-th scale, order-$(a_array[l]) response\")\nPLT.gcf()","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"(Image: )","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"The third Riesz-order state, subband j.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"l = 3\nprintln(\"Riesz order state: \", a_array[l])\n\nrsp = WRY[l][j]\nZ = max(abs(minimum(rsp)), abs(maximum(rsp)))\n\nPLT.figure(fig_num)\nfig_num += 1\nPLT.pcolormesh(\n    1:size(rsp,2),\n    size(rsp,1):-1:1,\n    rsp,\n    cmap = \"bwr\",\n    #cmap = \"gray\",\n    shading = \"auto\",\n    vmin = -Z,\n    vmax = Z,\n)\nPLT.colorbar()\nPLT.axis(\"scaled\")\nPLT.xlabel(\"x2 axis\")\nPLT.ylabel(\"x1 axis\")\nPLT.title(\"$j-th scale, order-$(a_array[l]) response\")\nPLT.gcf()","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"(Image: )","category":"page"},{"location":"demo/#Round-trip-discrepancy","page":"Demo: image analysis","title":"Round-trip discrepancy","text":"","category":"section"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"the inverse Riesz-wavelet transform first performs wavelet synthesis to gather the subband responses for each Riesz order state. Then it applies the inverse higher-order Riesz transform for each Riesz order state to combine into the filtered input. The residual is then added to the filtered input to get the original input. Therefore, if we keep track of the residual portion of the input, the Riesz-wavlet transform is a perfect reconstruction transform.","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"y_rec, a_array2 = RZ.rieszwaveletsynthesis(WRY, residual, order)\nprintln(\"Round-trip discrepancy: \", norm(y_rec - y));\n\nnothing","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"Round-trip discrepancy: 1.4719882595318903e-13\n","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"","category":"page"},{"location":"demo/","page":"Demo: image analysis","title":"Demo: image analysis","text":"This page was generated using Literate.jl.","category":"page"}]
}
